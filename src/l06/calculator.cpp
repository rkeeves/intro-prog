/*
  Main goal was to fail utterly at creating a simple script interpreter.
  
  Other goals:
  Evaluate expressions
  Basic operations
  Variables
  Native function calls
  
  Misc:
  Currently the script based functions are not working at all.
  The tree generated by the parser is mocked.
  The tree implementation does not use ptrs, just to keep it simple.
  The parser and lexer is currently not implemented.
  In L05 and C06, C07 we did an implementation for both of them + evaluation.
*/
#include <iostream>

#include "var.h"
#include "context.h"
#include "eval.h"

#include "calclib.h"

using namespace calc;

int main(){
  try{
    // Mock a really simple tree of expressions
    // print(true,10,3.14,'text',x);
    ExprTree tree(ExprType::FunctionCall,"");
    ExprNodeIdx root = tree.getRoot();
    tree.add(root,ExprType::StrLiteral,"print");
    tree.add(root,ExprType::BlnLiteral,"true");
    tree.add(root,ExprType::IntLiteral,"10");
    tree.add(root,ExprType::DblLiteral,"3.14");
    tree.add(root,ExprType::StrLiteral,"text");
    tree.add(root,ExprType::Symbol,"x");
    // Predefine a native function 'print' 
    // and a global variable 'x'
    Context ctx;
    ctx.defineNativeFunction("print",print);
    ctx.define("x",Var(7.8));
    // Evaluate the tree
    // The native print's side effect is that it writes to std::out
    std::cout << "Evaluation started " << std::endl;
    Var res = evalExpressionTree(tree,ctx);
    std::cout << "Evaluation returned the value: " << res << std::endl;
  }
  catch (std::exception& e) 
  {
		std::cerr << "exception: " << e.what() << std::endl;
		char c;
		while (std::cin >>c&& c!=';') ;
		return 1;
	}
	catch (...) 
  {
		std::cerr << "exception\n";
		char c;
		while (std::cin>>c && c!=';');
		return 2;
	}
}